# Lab4 Deadlock实验报告

### by 秦威 14353255

#### 1.死锁位置截图：
![](http://oe4493xaz.bkt.clouddn.com/deadlock.png)


#### 2.产生死锁的四个必要条件
  在操作系统中我们已经了解到操作系统产生死锁的原因主要是因为系统的资源不充足，各线程资源分配不当，进程运行推进的顺序不合适从而引发死锁。如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。


产生死锁的四个必要条件：

	（1） 互斥条件：一个资源每次只能被一个进程使用，也就是每个资源的实例只能被一个线程拥有。

	（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放，也就是即使它被阻塞无法运行，有别的进程需要它所占有的资源，它也不会让出这部分资源。

	（3） 非抢占条件:进程已获得的资源，在末使用完之前，不能被强行剥夺。

	（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系，比如A，B，C三个进程分别拥有a，b，c三种资源，A需要申请b资源，B需要申请c资源，而C需要申请a资源，此时这三个进程就陷入了一个三角循环当中都被阻塞无法运行，这是就形成了一个循环等待的条件。


#### 3.实验中程序产生死锁的理解

已知的前提是类A和B的methodA和methodB函数以及.last()定义的都是synchronized类型的，也就是说同一时刻最多只有一个线程执行该段代码，并且当这个线程在访问该代码段时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。

根据程序的运行示意图：

![](http://oe4493xaz.bkt.clouddn.com/lock1.png)


那么，显然，当t线程在被调度运行后会执行函数b.methodB(a)，即先访问类B中的.medthodB代码段，然后在该代码段中调用了a的.last()函数，也就是访问类A中的.last()代码段，这是没有任何问题的。但是，在while循环对count--执行完毕后，线程会执行a.methodA(b)，这个函数与b.methodB(a)正好反过来，先访问A中代码段，再访问B中代码段。

好了，理清楚上述代码的运行思路之后就简单了。如果b.methodB(a)这个函数在a.methodA(b)函数开始运行之前已经运行完毕的话，那么皆大欢喜，大家相安无事不会有死锁；如果b.methodB(a)在访问B中代码段的同时，a.methodA(b)也在访问A中的代码段，然后b.methodB(a)对B访问完毕的同时a.methodA(b)也对A访问完毕，那么非常幸运，撞车的机会擦肩而过，也不会发生死锁，但是访问两个类的速度应该是差不多的，大家的时间片也一样长，显然这种情况出现的概率比较小，不发生死锁的原因肯定是前一种更为合理。

很好，上面叙述的都是两个线程相安无事的时候。那么我们来考虑count这个变量，由于理论上b.methodB(a)和a.methodA(b)的执行时间应该差不多，那么由于count的存在，整个程序不断重复运行的时候，很有可能就会出现当b.methodB(a)还在访问B资源的时候，a.methodA(b)已经到了要执行b.last()的时候了，这个时候a.methodA(b)的线程占有了A中代码端的资源，但是要申请B中的代码段资源，但是b.methodB(a)还在执行B中的代码段，它占有着B中的资源，并且已经要区申请A的资源了，这个时候两者各持着对方需要的资源，却又想申请对方手中的资源，thanks god！死锁产生了。目的达成！
